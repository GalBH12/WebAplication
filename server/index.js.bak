require("dotenv").config();
const path = require("path");
const express = require("express");
const mongoose = require("mongoose");
mongoose.set("bufferCommands", false);
const cors = require("cors");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const nodemailer = require("nodemailer");
const User = require("./models/userschema");
const verifyToken = require("./middleware/auth");

const app = express();
const http = require("http").createServer(app);
const { Server } = require("socket.io");

const PORT = Number(process.env.PORT || 4000);
let DBJS_URI = undefined;
try {
  DBJS_URI = require("./db").MONGO_URI;
} catch (e) {}
const MONGO_URI =
  process.env.MONGO_URI || DBJS_URI || "mongodb://127.0.0.1:27017/map-app";
const JWT_SECRET = process.env.JWT_SECRET || "dev-secret";
const FRONTEND_ORIGIN =
  process.env.FRONTEND_ORIGIN || "http://localhost:5173";

app.use(
  cors({
    origin: FRONTEND_ORIGIN,
    credentials: true,
  })
);
app.use(express.json({ limit: "20mb" }));
app.use(express.urlencoded({ extended: true, limit: "20mb" }));
app.use(express.static(path.join(process.cwd(), "public")));

// Return 503 quickly if DB is not connected (avoid long buffering timeouts)
app.use((req, res, next) => {
  if (req.path.startsWith("/api") && mongoose.connection.readyState !== 1) {
    return res.status(503).json({ error: "Database not connected" });
  }
  next();
});

app.use("/api/admin", require("./routes/admin"));

mongoose
  .connect(MONGO_URI, { serverSelectionTimeoutMS: 10000 })
  .then(() => console.log("[DB] Connected"))
  .catch((err) => console.error("[DB] Connection error:", err?.message || err));

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: Number(process.env.SMTP_PORT || 587),
  auth: { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS },
});

function signToken(user) {
  return jwt.sign(
    {
      id: user._id.toString(),
      username: user.username,
      role: user.role || "user",
      banned: Boolean(user.banned),
    },
    JWT_SECRET,
    { expiresIn: "7d" }
  );
}
function verifyToken(req, res, next) {
  const auth = req.headers.authorization || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7) : null;
  if (!token) return res.status(401).json({ error: "missing token" });
  try {
    req.user = jwt.verify(token, JWT_SECRET);
    next();
  } catch {
    return res.status(401).json({ error: "invalid or expired token" });
  }
}

app.get("/api/health", (_req, res) => {
  res.json({ ok: true, ts: Date.now() });
});

app.post("/api/register", async (req, res) => {
  try {
    const {
      username,
      email,
      password,
      firstName,
      lastName,
      phone,
      birthDate,
    } = req.body || {};
    if (!username || !email || !password)
      return res.status(400).json({ error: "missing fields" });
    const exists = await User.findOne({ $or: [{ username }, { email }] });
    if (exists)
      return res.status(409).json({ error: "user or email already exists" });
    const hash = await bcrypt.hash(password, 10);
    await User.create({
      username,
      email,
      password: hash,
      firstName: firstName ?? "",
      lastName: lastName ?? "",
      phone: phone ?? "",
      birthDate: birthDate ? new Date(birthDate) : null,
      role: "user",
    });
    res.json({ success: true });
  } catch (e) {
    console.error("register error:", e?.message || e);
    res.status(500).json({ error: "server error" });
  }
});

app.post("/api/login", async (req, res) => {
  try {
    const { username, password } = req.body || {};
    const user = await User.findOne({ username });
    if (!user) return res.status(401).json({ error: "User not found" });
    if (user.banned)
      return res
        .status(403)
        .json({
          error:
            "Your account is suspended, contact us for more information.",
        });
    const valid = await bcrypt.compare(password, user.password);
    if (!valid) return res.status(401).json({ error: "Invalid password" });
    const token = signToken(user);
    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        _id: user._id,
        username: user.username,
        email: user.email,
        profilePicture: user.profilePicture ?? null,
        role: user.role || "user",
        banned: Boolean(user.banned),
        firstName: user.firstName ?? "",
        lastName: user.lastName ?? "",
        phone: user.phone ?? "",
        birthDate: user.birthDate || null,
      },
    });
  } catch (e) {
    console.error("login error:", e?.message || e);
    res.status(500).json({ error: "server error" });
  }
});

app.get("/api/me", verifyToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select(
      "-password -resetToken -resetTokenExpiration"
    );
    if (!user) return res.status(404).json({ error: "User not found" });
    res.json({
      user: {
        id: user._id,
        _id: user._id,
        username: user.username,
        email: user.email,
        profilePicture: user.profilePicture ?? null,
        role: user.role || "user",
        banned: Boolean(user.banned),
        firstName: user.firstName ?? "",
        lastName: user.lastName ?? "",
        phone: user.phone ?? "",
        birthDate: user.birthDate || null,
      },
    });
  } catch (e) {
    console.error("me error:", e?.message || e);
    res.status(500).json({ error: "server error" });
  }
});

app.patch("/api/me", verifyToken, async (req, res) => {
  try {
    const { firstName, lastName, phone, birthDate, email } = req.body || {};
    const update = {};
    if (typeof firstName === "string") update.firstName = firstName;
    if (typeof lastName === "string") update.lastName = lastName;
    if (typeof phone === "string") update.phone = phone;
    if (typeof email === "string") update.email = email;
    if (birthDate !== undefined)
      update.birthDate = birthDate ? new Date(birthDate) : null;
    const user = await User.findByIdAndUpdate(req.user.id, update, {
      new: true,
      runValidators: true,
      select: "-password -resetToken -resetTokenExpiration",
    });
    if (!user) return res.status(404).json({ error: "User not found" });
    res.json({
      user: {
        id: user._id,
        _id: user._id,
        username: user.username,
        email: user.email,
        profilePicture: user.profilePicture ?? null,
        role: user.role || "user",
        banned: Boolean(user.banned),
        firstName: user.firstName ?? "",
        lastName: user.lastName ?? "",
        phone: user.phone ?? "",
        birthDate: user.birthDate || null,
      },
    });
  } catch (e) {
    console.error("update me error:", e?.message || e);
    res.status(500).json({ error: "server error" });
  }
});

app.post("/api/forgotpasssender", async (req, res) => {
  try {
    const { email } = req.body || {};
    const user = await User.findOne({ email });
    if (!user) return res.status(404).send("User not found");
    const secret = JWT_SECRET + user.password;
    const token = jwt.sign({ email: user.email, id: user._id }, secret, {
      expiresIn: "20h",
    });
    const link = `http://localhost:5173/forgotpass/${user._id}/${token}`;
    await transporter.sendMail({
      from: "no-reply@example.com",
      to: user.email,
      subject: "Reset your password",
      html: `<p>Click below to reset your password:</p><a href="${link}">${link}</a>`,
    });
    res.json({ sent: true });
  } catch (e) {
    console.error("forgotpasssender error:", e?.message || e);
    res.status(500).json({ error: "server error" });
  }
});

app.post("/api/resetpass/:id/:token", async (req, res) => {
  try {
    const { id, token } = req.params;
    const { password } = req.body || {};
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ error: "User not found" });
    const secret = JWT_SECRET + user.password;
    try {
      jwt.verify(token, secret);
    } catch {
      return res.status(400).json({ error: "invalid or expired token" });
    }
    user.password = await bcrypt.hash(password, 10);
    await user.save();
    res.json({ success: true });
  } catch (e) {
    console.error("resetpass link error:", e?.message || e);
    res.status(500).json({ error: "server error" });
  }
});

app.post("/api/resetpass", async (req, res) => {
  try {
    const { username, oldPassword, newPassword } = req.body || {};
    const user = await User.findOne({ username });
    if (!user) return res.status(404).json({ error: "User not found" });
    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch)
      return res.status(400).json({ error: "Incorrect current password" });
    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();
    res.json({ message: "Password changed successfully" });
  } catch (e) {
    console.error("resetpass change error:", e?.message || e);
    res.status(500).json({ error: "server error" });
  }
});

app.use("/api/tracks", require("./routes/tracks"));

const io = new Server(http, {
  cors: {
    origin: FRONTEND_ORIGIN,
    methods: ["GET", "POST"],
  },
});

// presence map (socket.id -> { id, email, username, displayName })
const onlineUsers = new Map();

io.on("connection", (socket) => {
  socket.on("auth", async (token) => {
    try {
      const payload = jwt.verify(token, JWT_SECRET);

      let u = null;
      try {
        u = await User.findById(payload.id).lean();
      } catch {}

      const email = u?.email || "";
      const username = u?.username || "";
      const firstName = u?.firstName || "";
      const lastName = u?.lastName || "";
      const displayName =
        [firstName, lastName].filter(Boolean).join(" ") ||
        username ||
        email ||
        "unknown";

      onlineUsers.set(socket.id, {
        id: payload.id,
        email,
        username,
        displayName,
      });

      const list = Array.from(onlineUsers.values()).map((x) => x.displayName);
      io.emit("presence", Array.from(new Set(list)));
    } catch {
      socket.emit("auth_error", "invalid token");
    }
  });

  socket.on("chat_message", (msg) => {
    const from = onlineUsers.get(socket.id);
    const fromEmail = from?.email || from?.displayName || "unknown";
    const fromName = from?.displayName || "unknown";
    const text = String(msg?.text || "").slice(0, 1000);
    const to = msg?.to || undefined;

    const payload = { text, fromEmail, fromName, to };

    if (to) {
      for (const [sid, u] of onlineUsers.entries()) {
        if (u.displayName === to) io.to(sid).emit("chat_message", payload);
      }
      socket.emit("chat_message", payload);
    } else {
      io.emit("chat_message", payload);
    }
  });

  socket.on("disconnect", () => {
    onlineUsers.delete(socket.id);
    const list = Array.from(onlineUsers.values()).map((x) => x.displayName);
    io.emit("presence", Array.from(new Set(list)));
  });
});

http.listen(PORT, () => {
  console.log(`[API] Listening on http://localhost:${PORT}`);
  console.log(`[CORS] Allowed origin: ${FRONTEND_ORIGIN}`);
  console.log(`[Socket.IO] Ready`);
});
